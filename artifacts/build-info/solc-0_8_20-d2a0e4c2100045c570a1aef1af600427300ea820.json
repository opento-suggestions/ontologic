{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_20-d2a0e4c2100045c570a1aef1af600427300ea820",
  "solcVersion": "0.8.20",
  "solcLongVersion": "0.8.20+commit.a1b79de6",
  "userSourceNameMap": {
    "contracts/reasoningContract.sol": "project/contracts/reasoningContract.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "shanghai",
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/reasoningContract.sol": {
        "content": "// SPDX-License-Identifier: Apache-2.0\r\npragma solidity ^0.8.20;\r\n\r\n/**\r\n * @title ReasoningContract - Triadic Proof-of-Reasoning on Hedera\r\n * @author Ontologic Team\r\n * @notice Implements epistemic triad: Peirce (additive), Tarski (subtractive), Floridi (entity)\r\n * @dev This contract is part of the Ontologic three-layer provenance architecture:\r\n *      Layer 1: CONTRACTCALL - Validates input tokens and applies reasoning rules\r\n *      Layer 2: TOKENMINT - Mints output tokens via HTS as material consequence\r\n *      Layer 3: HCS MESSAGE - External proof submission to consensus topic (handled by client)\r\n *\r\n * Ontologic ReasoningContract — v0.6.0\r\n * Floridi Layer: Evidence-based entity attestation with domain verdict logic.\r\n *\r\n * v0.6.0 Changes:\r\n * - Implemented publishEntity with evidence validation\r\n * - Added domain verdict logic (LIGHT→WHITE, PAINT→BLACK)\r\n * - Entity attestation requires valid CMY proof evidence\r\n * - Removed DebugPair event (debugging complete)\r\n *\r\n * v0.5.0 Base Implementation:\r\n * - ProofAdd (Peirce): Additive reasoning with token minting\r\n * - ProofCheck (Tarski): Subtractive reasoning with boolean verdict\r\n * - ProofEntity (Floridi): Entity manifest publication with projections\r\n * - ProofReplay: Idempotent proof execution with replay detection\r\n * - Projection registry: Domain-scoped RGB values for tokens\r\n * - Subtractive math: LIGHT (channelwise RGB), PAINT (CMY model)\r\n * - Triple-equality: hash_local == hash_event == hash_hcs\r\n * - Canonical proof caching: One proof per (domain, operator, inputs)\r\n * - 9-token configuration: RGB+CMY+WHITE+BLACK+PURPLE\r\n */\r\n\r\n/**\r\n * @dev ERC20 interface for token balance and decimals queries\r\n */\r\ninterface IERC20 {\r\n    /// @notice Get token balance of an account\r\n    /// @param account Address to query\r\n    /// @return balance Token balance in atomic units\r\n    function balanceOf(address account) external view returns (uint256 balance);\r\n\r\n    /// @notice Get number of decimals for token\r\n    /// @return decimals Number of decimal places\r\n    function decimals() external view returns (uint8 decimals);\r\n}\r\n\r\n/**\r\n * @dev Hedera Token Service interface for token minting operations\r\n * @custom:address 0x167 (HTS precompile on Hedera)\r\n * @custom:security Contract must have supply key permissions for tokens being minted\r\n */\r\ninterface IHederaTokenService {\r\n    /**\r\n     * @notice Mint fungible tokens\r\n     * @dev For fungible tokens, metadata array should be empty\r\n     * @param token Address of token to mint\r\n     * @param amount Number of tokens to mint (in atomic units)\r\n     * @param metadata Array of metadata (unused for fungible tokens)\r\n     * @return responseCode HTS response code (22 = SUCCESS)\r\n     * @return newTotalSupply Updated total supply after minting\r\n     * @return serialNumbers Serial numbers for NFTs (empty for fungible)\r\n     */\r\n    function mintToken(\r\n        address token,\r\n        uint64 amount,\r\n        bytes[] calldata metadata\r\n    )\r\n        external\r\n        returns (int64 responseCode, uint64 newTotalSupply, int64[] memory serialNumbers);\r\n}\r\n\r\ncontract ReasoningContract {\r\n    /*//////////////////////////////////////////////////////////////\r\n                            STATE VARIABLES\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    /// @notice Hedera Token Service precompile address\r\n    /// @dev Fixed address on Hedera network\r\n    IHederaTokenService public constant HTS = IHederaTokenService(address(0x167));\r\n\r\n    /// @notice Domain constants for deterministic hashing\r\n    bytes32 public constant D_LIGHT = keccak256(\"color.light\");\r\n    bytes32 public constant D_PAINT = keccak256(\"color.paint\");\r\n    bytes32 public constant D_ENTITY_LIGHT = keccak256(\"color.entity.light\");\r\n    bytes32 public constant D_ENTITY_PAINT = keccak256(\"color.entity.paint\");\r\n\r\n    /// @notice Operator constants for deterministic hashing\r\n    bytes32 public constant OP_ADD = keccak256(\"mix_add@v1\");\r\n    bytes32 public constant OP_SUB = keccak256(\"check_sub@v1\");\r\n    bytes32 public constant OP_ATTEST = keccak256(\"attest_palette@v1\");\r\n\r\n    /// @notice EVM address for $RED token (soft-gate)\r\n    /// @dev Configurable post-deployment, initialized to zero\r\n    address public RED_TOKEN_ADDR;\r\n\r\n    /// @notice EVM address for $GREEN token (soft-gate)\r\n    /// @dev Configurable post-deployment, initialized to zero\r\n    address public GREEN_TOKEN_ADDR;\r\n\r\n    /// @notice EVM address for $BLUE token (soft-gate)\r\n    /// @dev Configurable post-deployment, initialized to zero\r\n    address public BLUE_TOKEN_ADDR;\r\n\r\n    /// @notice EVM address for $YELLOW token (RGB+CMY secondary)\r\n    /// @dev Configurable post-deployment, initialized to zero\r\n    address public YELLOW_TOKEN_ADDR;\r\n\r\n    /// @notice EVM address for $CYAN token (RGB+CMY secondary)\r\n    /// @dev Configurable post-deployment, initialized to zero\r\n    address public CYAN_TOKEN_ADDR;\r\n\r\n    /// @notice EVM address for $MAGENTA token (RGB+CMY secondary)\r\n    /// @dev Configurable post-deployment, initialized to zero\r\n    address public MAGENTA_TOKEN_ADDR;\r\n\r\n    /// @notice EVM address for $WHITE token (derived output)\r\n    /// @dev Configurable post-deployment, initialized to zero\r\n    address public WHITE_TOKEN_ADDR;\r\n\r\n    /// @notice EVM address for $BLACK token (CMYK 'K' component)\r\n    /// @dev Configurable post-deployment, initialized to zero\r\n    address public BLACK_TOKEN_ADDR;\r\n\r\n    /// @notice EVM address for $PURPLE token (derived output)\r\n    /// @dev Configurable post-deployment, initialized to zero\r\n    address public PURPLE_TOKEN_ADDR;\r\n\r\n    /// @notice Contract owner (can set rules and update schema)\r\n    address public owner;\r\n\r\n    /// @notice Reasoning protocol schema hash for versioning\r\n    bytes32 public reasoningSchemaHash;\r\n\r\n    /**\r\n     * @notice Reasoning rule structure\r\n     * @param domain Hashed domain identifier (e.g., keccak256(\"color.paint\"))\r\n     * @param operator Hashed operation identifier (e.g., keccak256(\"mix_paint\"))\r\n     * @param inputs Array of input token addresses required for reasoning\r\n     * @param outputToken Address of token to mint as reasoning output\r\n     * @param ratioNumerator Mint ratio numerator (denominator is 1)\r\n     * @param active Whether rule is currently enabled\r\n     */\r\n    struct Rule {\r\n        bytes32 domain;\r\n        bytes32 operator;\r\n        address[] inputs;\r\n        address outputToken;\r\n        uint64 ratioNumerator;\r\n        bool active;\r\n    }\r\n\r\n    /// @notice Mapping of rule IDs to rule definitions\r\n    /// @dev Rule ID = keccak256(abi.encode(domain, operator, inputs))\r\n    mapping(bytes32 => Rule) public rules;\r\n\r\n    /// @notice Projection registry: domain → token → RGB24 value\r\n    /// @dev RGB24 format: 0xRRGGBB (e.g., 0xFF00FF for purple in light domain)\r\n    mapping(bytes32 => mapping(address => uint24)) public projections;\r\n\r\n    /// @notice Canonical proof cache for replay detection\r\n    /// @dev Maps proofHash → true if proof has been executed\r\n    mapping(bytes32 => bool) public proofSeen;\r\n\r\n    /// @notice Inputs hash guard for proof integrity\r\n    /// @dev Maps proofHash → inputsHash to prevent replay with mutated inputs\r\n    mapping(bytes32 => bytes32) public inputsHashOf;\r\n\r\n    /// @notice Cached outputs for replayed proofs\r\n    /// @dev Maps proofHash → (outputToken, outputAmount)\r\n    struct CachedOutput {\r\n        address token;\r\n        uint64 amount;\r\n    }\r\n    mapping(bytes32 => CachedOutput) public cachedOutputs;\r\n\r\n    /**\r\n     * @notice Proof data bundle for v0.4.2 reasoning functions\r\n     * @dev Bundles hash parameters and URI to reduce stack depth\r\n     * @custom:field inputsHash Preimage hash for input validation\r\n     * @custom:field proofHash keccak256 hash of canonical proof JSON\r\n     * @custom:field factHash keccak256 hash of HCS message (reserved)\r\n     * @custom:field ruleHash Hash of rule tuple (domain, operator, inputs) (reserved)\r\n     * @custom:field canonicalUri Short URI for proof storage (e.g., \"hcs://0.0.7204585/...\")\r\n     */\r\n    struct ProofData {\r\n        bytes32 inputsHash;\r\n        bytes32 proofHash;\r\n        bytes32 factHash;\r\n        bytes32 ruleHash;\r\n        string canonicalUri;\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                              CUSTOM ERRORS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    /// @notice Thrown when entity evidence is invalid or incomplete\r\n    error Ontologic_InvalidEntity();\r\n\r\n    /// @notice Thrown when a required proof is missing from evidence\r\n    error Ontologic_MissingEvidence();\r\n\r\n    /// @notice Thrown when entity domain is not recognized\r\n    error Ontologic_UnknownEntityDomain();\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                                EVENTS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    /**\r\n     * @notice Emitted when a new reasoning rule is configured\r\n     * @param ruleId Unique identifier for the rule\r\n     * @param domain Reasoning domain hash\r\n     * @param operator Operation identifier hash\r\n     * @param inputs Array of required input token addresses\r\n     * @param outputToken Address of output token to mint\r\n     * @param ratio Mint ratio numerator\r\n     */\r\n    event RuleSet(\r\n        bytes32 indexed ruleId,\r\n        bytes32 domain,\r\n        bytes32 operator,\r\n        address[] inputs,\r\n        address outputToken,\r\n        uint64 ratio\r\n    );\r\n\r\n    /**\r\n     * @notice DEBUG: Emitted to trace inputsHash comparison in reasonAdd\r\n     * @param clientHash InputsHash provided by client\r\n     * @param contractHash InputsHash computed by contract\r\n     * @param matches Whether they match\r\n     */\r\n    event DebugInputsHash(\r\n        bytes32 clientHash,\r\n        bytes32 contractHash,\r\n        bool matches\r\n    );\r\n\r\n    /**\r\n     * @notice Emitted when additive reasoning is executed (Peirce/ProofAdd)\r\n     * @dev This event provides the proof hash and URI for Layer 3 (HCS) submission\r\n     * @param ruleId Rule that was executed\r\n     * @param caller Account that initiated the reasoning\r\n     * @param inputUnits Number of input units consumed\r\n     * @param mintedUnits Number of output units minted\r\n     * @param proofHash keccak256 hash of canonical proof JSON\r\n     * @param canonicalUri URI for HCS message or proof storage\r\n     */\r\n    event ProofAdd(\r\n        bytes32 indexed ruleId,\r\n        address indexed caller,\r\n        uint64 inputUnits,\r\n        uint64 mintedUnits,\r\n        bytes32 indexed proofHash,\r\n        string canonicalUri\r\n    );\r\n\r\n    /**\r\n     * @notice Emitted when subtractive reasoning check is executed (Tarski/ProofCheck)\r\n     * @param proofHash keccak256 hash of canonical proof JSON\r\n     * @param domain Domain hash (e.g., keccak256(\"color.light\"))\r\n     * @param A First input token address\r\n     * @param B Second input token address\r\n     * @param C Result token address to check\r\n     * @param verdict Boolean result: true if A - B == C in domain\r\n     * @param canonicalUri URI for HCS message or proof storage\r\n     */\r\n    event ProofCheck(\r\n        bytes32 indexed proofHash,\r\n        bytes32 indexed domain,\r\n        address A,\r\n        address B,\r\n        address C,\r\n        bool verdict,\r\n        string canonicalUri\r\n    );\r\n\r\n    /**\r\n     * @notice Emitted when entity manifest is published (Floridi/ProofEntity)\r\n     * @param manifestHash keccak256 hash of entity manifest JSON\r\n     * @param token Token address being described\r\n     * @param uri URI for manifest storage (HCS, IPFS, etc.)\r\n     * @param controller Address publishing the manifest\r\n     */\r\n    event ProofEntity(\r\n        bytes32 indexed manifestHash,\r\n        address indexed token,\r\n        string uri,\r\n        address indexed controller\r\n    );\r\n\r\n    /**\r\n     * @notice Emitted when a proof is replayed (already seen)\r\n     * @dev Lightweight event for duplicate proof submissions\r\n     * @param proofHash keccak256 hash of canonical proof JSON\r\n     * @param caller Account attempting the replay\r\n     */\r\n    event ProofReplay(\r\n        bytes32 indexed proofHash,\r\n        address indexed caller\r\n    );\r\n\r\n    /**\r\n     * @notice Emitted when token addresses are configured\r\n     * @dev Allows verification of token configuration via event logs\r\n     * @param red EVM address for RED token\r\n     * @param green EVM address for GREEN token\r\n     * @param blue EVM address for BLUE token\r\n     * @param yellow EVM address for YELLOW token\r\n     * @param cyan EVM address for CYAN token\r\n     * @param magenta EVM address for MAGENTA token\r\n     * @param white EVM address for WHITE token\r\n     * @param black EVM address for BLACK token\r\n     * @param purple EVM address for PURPLE token\r\n     */\r\n    event TokenAddressesUpdated(\r\n        address indexed red,\r\n        address indexed green,\r\n        address indexed blue,\r\n        address yellow,\r\n        address cyan,\r\n        address magenta,\r\n        address white,\r\n        address black,\r\n        address purple\r\n    );\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                               MODIFIERS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    /// @notice Restricts function access to contract owner\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"not owner\");\r\n        _;\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                             CONSTRUCTOR\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    /**\r\n     * @notice Initialize the ReasoningContract\r\n     * @param _schemaHash Hash of the reasoning protocol schema version\r\n     */\r\n    constructor(bytes32 _schemaHash) {\r\n        owner = msg.sender;\r\n        reasoningSchemaHash = _schemaHash;\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                          OWNER FUNCTIONS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    /**\r\n     * @notice Update the reasoning protocol schema hash\r\n     * @dev Only callable by owner, used for protocol upgrades\r\n     * @param _schemaHash New schema hash\r\n     */\r\n    function setSchemaHash(bytes32 _schemaHash) external onlyOwner {\r\n        reasoningSchemaHash = _schemaHash;\r\n    }\r\n\r\n    /**\r\n     * @notice Configure token addresses post-deployment (v0.4.5 - 9 tokens)\r\n     * @dev Only callable by owner, breaks circular dependency with token creation\r\n     * @dev This allows contract deployment before tokens are created\r\n     * @param _red EVM address for RED token\r\n     * @param _green EVM address for GREEN token\r\n     * @param _blue EVM address for BLUE token\r\n     * @param _yellow EVM address for YELLOW token\r\n     * @param _cyan EVM address for CYAN token\r\n     * @param _magenta EVM address for MAGENTA token\r\n     * @param _white EVM address for WHITE token\r\n     * @param _black EVM address for BLACK token\r\n     * @param _purple EVM address for PURPLE token\r\n     */\r\n    function setTokenAddresses(\r\n        address _red,\r\n        address _green,\r\n        address _blue,\r\n        address _yellow,\r\n        address _cyan,\r\n        address _magenta,\r\n        address _white,\r\n        address _black,\r\n        address _purple\r\n    ) external onlyOwner {\r\n        require(\r\n            _red != address(0) && _green != address(0) && _blue != address(0) &&\r\n            _yellow != address(0) && _cyan != address(0) && _magenta != address(0) &&\r\n            _white != address(0) && _black != address(0) && _purple != address(0),\r\n            \"zero addr\"\r\n        );\r\n\r\n        RED_TOKEN_ADDR = _red;\r\n        GREEN_TOKEN_ADDR = _green;\r\n        BLUE_TOKEN_ADDR = _blue;\r\n        YELLOW_TOKEN_ADDR = _yellow;\r\n        CYAN_TOKEN_ADDR = _cyan;\r\n        MAGENTA_TOKEN_ADDR = _magenta;\r\n        WHITE_TOKEN_ADDR = _white;\r\n        BLACK_TOKEN_ADDR = _black;\r\n        PURPLE_TOKEN_ADDR = _purple;\r\n\r\n        emit TokenAddressesUpdated(_red, _green, _blue, _yellow, _cyan, _magenta, _white, _black, _purple);\r\n    }\r\n\r\n    /**\r\n     * @notice Configure a new reasoning rule\r\n     * @dev Rule ID is computed as keccak256(abi.encode(domain, operator, inputs))\r\n     * @dev Supports 2-token rules (RED + BLUE) and 3-token rules (RED + GREEN + BLUE)\r\n     * @param domain Domain identifier hash (e.g., keccak256(\"color.paint\"))\r\n     * @param operator Operation identifier hash (e.g., keccak256(\"mix_paint\"))\r\n     * @param inputs Array of input token addresses (2 or 3 tokens required)\r\n     * @param outputToken Address of output token to mint\r\n     * @param ratioNumerator Mint ratio (e.g., 1 means 1:1 ratio)\r\n     * @return ruleId The computed rule identifier\r\n     */\r\n    function setRule(\r\n        bytes32 domain,\r\n        bytes32 operator,\r\n        address[] calldata inputs,\r\n        address outputToken,\r\n        uint64 ratioNumerator\r\n    ) external onlyOwner returns (bytes32 ruleId) {\r\n        require(inputs.length >= 1 && inputs.length <= 4, \"bad arity\");\r\n        require(outputToken != address(0), \"no output\");\r\n\r\n        // Soft-gate validation: support 2-token and 3-token rules\r\n        require(inputs.length == 2 || inputs.length == 3, \"must provide 2 or 3 inputs\");\r\n\r\n        bool hasRed = false;\r\n        bool hasGreen = false;\r\n        bool hasBlue = false;\r\n\r\n        for (uint256 i = 0; i < inputs.length; i++) {\r\n            if (inputs[i] == RED_TOKEN_ADDR) hasRed = true;\r\n            if (inputs[i] == GREEN_TOKEN_ADDR) hasGreen = true;\r\n            if (inputs[i] == BLUE_TOKEN_ADDR) hasBlue = true;\r\n        }\r\n\r\n        // For 2-token rules: require RED + BLUE\r\n        // For 3-token rules: require RED + GREEN + BLUE\r\n        if (inputs.length == 2) {\r\n            require(hasRed && hasBlue, \"2-token rules require RED and BLUE\");\r\n        } else if (inputs.length == 3) {\r\n            require(hasRed && hasGreen && hasBlue, \"3-token rules require RED, GREEN, and BLUE\");\r\n        }\r\n\r\n        // Compute deterministic rule ID\r\n        ruleId = keccak256(abi.encode(domain, operator, inputs));\r\n        rules[ruleId] = Rule(domain, operator, inputs, outputToken, ratioNumerator, true);\r\n\r\n        emit RuleSet(ruleId, domain, operator, inputs, outputToken, ratioNumerator);\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                        REASONING FUNCTIONS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    /**\r\n     * @notice Execute additive reasoning (Peirce/ProofAdd) - Legacy v0.4.1 interface\r\n     * @dev Validates input token balances, mints output tokens, and emits proof event\r\n     * @dev Caller must hold sufficient balance of all input tokens\r\n     * @dev Contract must have supply key permissions for output token\r\n     * @dev NOTE: Does not support replay detection - use reasonAdd() for v0.4.2\r\n     * @param ruleId Identifier of rule to execute\r\n     * @param inputUnits Number of input units to process\r\n     * @param proofHash keccak256 hash of canonical proof JSON (v0.4 with layer:\"peirce\")\r\n     * @param canonicalUri URI for HCS message or proof storage\r\n     * @return minted Number of output tokens minted\r\n     */\r\n    function reason(\r\n        bytes32 ruleId,\r\n        uint64 inputUnits,\r\n        bytes32 proofHash,\r\n        string calldata canonicalUri\r\n    ) external returns (uint64 minted) {\r\n        Rule storage r = rules[ruleId];\r\n        require(r.active, \"rule off\");\r\n\r\n        // v0.5.0: Disabled ERC-20 balanceOf check (HTS tokens don't implement balanceOf from contracts)\r\n        // TODO v0.6: Replace with HTS precompile balance query at 0x167\r\n        // Validate caller has sufficient input token balances\r\n        // for (uint256 i = 0; i < r.inputs.length; i++) {\r\n        //     IERC20 token = IERC20(r.inputs[i]);\r\n        //     uint8 decimals = _safeDecimals(r.inputs[i]);\r\n        //     uint256 requiredAtoms = uint256(inputUnits) * (10 ** decimals);\r\n        //     require(token.balanceOf(msg.sender) >= requiredAtoms, \"insufficient input\");\r\n        // }\r\n\r\n        // Calculate mint amount and call HTS precompile\r\n        minted = inputUnits * r.ratioNumerator;\r\n        (int64 responseCode,,) = HTS.mintToken(r.outputToken, minted, new bytes[](0));\r\n        require(responseCode == 22, \"mint fail\"); // 22 == HTS SUCCESS\r\n\r\n        // Emit Peirce proof event (layer:\"peirce\", mode:\"additive\")\r\n        emit ProofAdd(ruleId, msg.sender, inputUnits, minted, proofHash, canonicalUri);\r\n    }\r\n\r\n    /**\r\n     * @notice Execute additive reasoning with replay detection (v0.4.2)\r\n     * @dev Idempotent: replays emit ProofReplay and return cached output\r\n     * @dev Enforces domain=D_LIGHT and uses deterministic RGB→CMY mapping\r\n     * @param A First input token address\r\n     * @param B Second input token address\r\n     * @param domainHash Domain identifier (must be D_LIGHT)\r\n     * @param p Proof data bundle (inputsHash, proofHash, factHash, ruleHash, canonicalUri)\r\n     * @return outToken Address of output token\r\n     * @return amount Number of output tokens minted (or cached amount for replay)\r\n     */\r\n    function reasonAdd(\r\n        address A,\r\n        address B,\r\n        bytes32 domainHash,\r\n        ProofData calldata p\r\n    ) external returns (address outToken, uint64 amount) {\r\n        // DEBUG: Emit entry point\r\n        emit DebugInputsHash(domainHash, D_LIGHT, domainHash == D_LIGHT);\r\n\r\n        // Enforce light domain only for additive reasoning\r\n        require(domainHash == D_LIGHT, \"domain must be D_LIGHT\");\r\n\r\n        // DEBUG: Emit inputsHash comparison before validation\r\n        bytes32 contractComputed = _inputsHashAdd(A, B, domainHash);\r\n        emit DebugInputsHash(p.inputsHash, contractComputed, p.inputsHash == contractComputed);\r\n\r\n        // Validate inputsHash matches computed hash\r\n        require(p.inputsHash == contractComputed, \"inputsHash-mismatch\");\r\n\r\n        // Check for replay\r\n        if (proofSeen[p.proofHash]) {\r\n            emit ProofReplay(p.proofHash, msg.sender);\r\n            CachedOutput memory cached = cachedOutputs[p.proofHash];\r\n            return (cached.token, cached.amount);\r\n        }\r\n\r\n        // Fresh proof: use deterministic RGB→CMY mapping\r\n        (outToken, amount) = _mixAddDeterministic(A, B);\r\n\r\n        // v0.5.0: Disabled ERC-20 balanceOf checks (HTS tokens don't implement balanceOf from contracts)\r\n        // TODO v0.6: Replace with HTS precompile balance query at 0x167\r\n        // Validate caller has sufficient input token balances\r\n        // IERC20 tokenA = IERC20(A);\r\n        // IERC20 tokenB = IERC20(B);\r\n        // uint8 decimalsA = _safeDecimals(A);\r\n        // uint8 decimalsB = _safeDecimals(B);\r\n        // require(tokenA.balanceOf(msg.sender) >= 10 ** decimalsA, \"insufficient A\");\r\n        // require(tokenB.balanceOf(msg.sender) >= 10 ** decimalsB, \"insufficient B\");\r\n\r\n        // Mint output token via HTS precompile\r\n        (int64 responseCode,,) = HTS.mintToken(outToken, amount, new bytes[](0));\r\n        require(responseCode == 22, \"mint fail\");\r\n\r\n        // Cache proof and output\r\n        proofSeen[p.proofHash] = true;\r\n        inputsHashOf[p.proofHash] = p.inputsHash;\r\n        cachedOutputs[p.proofHash] = CachedOutput(outToken, amount);\r\n\r\n        // Emit Peirce proof event (layer:\"peirce\", mode:\"additive\")\r\n        emit ProofAdd(p.proofHash, msg.sender, 1, amount, p.proofHash, p.canonicalUri);\r\n    }\r\n\r\n    /**\r\n     * @notice Deterministic RGB→CMY additive color mapping\r\n     * @dev Maps (RED,GREEN)→YELLOW, (GREEN,BLUE)→CYAN, (RED,BLUE)→MAGENTA\r\n     * @param A First input token (order-invariant)\r\n     * @param B Second input token (order-invariant)\r\n     * @return outToken Address of output token\r\n     * @return amount Number of tokens to mint (always 1)\r\n     */\r\n    function _mixAddDeterministic(address A, address B)\r\n        internal\r\n        view\r\n        returns (address outToken, uint64 amount)\r\n    {\r\n        // Sort inputs for order-invariance\r\n        (address X, address Y) = A < B ? (A, B) : (B, A);\r\n\r\n        // Map RGB primaries to CMY secondaries\r\n        if (X == RED_TOKEN_ADDR && Y == GREEN_TOKEN_ADDR) {\r\n            return (YELLOW_TOKEN_ADDR, 1);\r\n        }\r\n        if (X == GREEN_TOKEN_ADDR && Y == BLUE_TOKEN_ADDR) {\r\n            return (CYAN_TOKEN_ADDR, 1);\r\n        }\r\n        if (X == RED_TOKEN_ADDR && Y == BLUE_TOKEN_ADDR) {\r\n            return (MAGENTA_TOKEN_ADDR, 1);\r\n        }\r\n\r\n        revert(\"unsupported-additive-pair\");\r\n    }\r\n\r\n    /**\r\n     * @notice Register a projection for a token in a domain\r\n     * @dev Only owner can register projections\r\n     * @param domain Domain hash (e.g., keccak256(\"color.light\"))\r\n     * @param token Token address\r\n     * @param rgb24 RGB value in 24-bit format (0xRRGGBB)\r\n     */\r\n    function registerProjection(bytes32 domain, address token, uint24 rgb24) external onlyOwner {\r\n        projections[domain][token] = rgb24;\r\n    }\r\n\r\n    /**\r\n     * @notice Execute subtractive reasoning check with replay detection (Tarski/ProofCheck)\r\n     * @dev Returns boolean verdict, never reverts on logical failure\r\n     * @dev Uses projection registry for RGB values\r\n     * @dev Idempotent: replays emit ProofReplay and re-compute verdict\r\n     * @param A First input token address\r\n     * @param B Second input token address\r\n     * @param C Result token address to verify\r\n     * @param domainHash Domain hash for subtractive logic (D_LIGHT or D_PAINT)\r\n     * @param p Proof data bundle (inputsHash, proofHash, factHash, ruleHash, canonicalUri)\r\n     * @return verdict True if A - B == C in the specified domain\r\n     */\r\n    function reasonCheckSub(\r\n        address A,\r\n        address B,\r\n        address C,\r\n        bytes32 domainHash,\r\n        ProofData calldata p\r\n    ) external returns (bool verdict) {\r\n        // Validate inputsHash\r\n        require(p.inputsHash == inputsHashSub(A, B, C, domainHash), \"inputsHash-mismatch\");\r\n\r\n        // Check for replay\r\n        if (proofSeen[p.proofHash]) {\r\n            emit ProofReplay(p.proofHash, msg.sender);\r\n            // Re-compute verdict (negligible cost)\r\n        }\r\n\r\n        // Fetch and validate projections\r\n        uint24 rgbA = projections[domainHash][A];\r\n        if (rgbA == 0 || projections[domainHash][B] == 0 || projections[domainHash][C] == 0) {\r\n            if (!proofSeen[p.proofHash]) {\r\n                proofSeen[p.proofHash] = true;\r\n                inputsHashOf[p.proofHash] = p.inputsHash;\r\n                emit ProofCheck(p.proofHash, domainHash, A, B, C, false, p.canonicalUri);\r\n            }\r\n            return false;\r\n        }\r\n\r\n        // Compute verdict: A - B == C?\r\n        verdict = (_subtractRGB(rgbA, projections[domainHash][B], domainHash) == projections[domainHash][C]);\r\n\r\n        // Cache proof and emit event (skip if replay)\r\n        if (!proofSeen[p.proofHash]) {\r\n            proofSeen[p.proofHash] = true;\r\n            inputsHashOf[p.proofHash] = p.inputsHash;\r\n            emit ProofCheck(p.proofHash, domainHash, A, B, C, verdict, p.canonicalUri);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Publish entity manifest with evidence validation (Floridi/ProofEntity)\r\n     * @dev Validates CMY proof evidence and mints verdict token based on domain\r\n     * @dev LIGHT domain (WHITE verdict): Requires YELLOW, CYAN, MAGENTA proofs\r\n     * @dev PAINT domain (BLACK verdict): Requires YELLOW, CYAN, MAGENTA proofs\r\n     * @param token Verdict token address (WHITE or BLACK)\r\n     * @param manifestHash keccak256 hash of entity manifest JSON\r\n     * @param uri URI for manifest storage (HCS topic, IPFS, etc.)\r\n     * @return ok True if entity attestation succeeded\r\n     */\r\n    function publishEntity(\r\n        address token,\r\n        bytes32 manifestHash,\r\n        string calldata uri\r\n    ) external returns (bool ok) {\r\n        // Determine domain and verdict based on token\r\n        bytes32 domain;\r\n        address verdictToken;\r\n\r\n        if (token == WHITE_TOKEN_ADDR) {\r\n            domain = D_ENTITY_LIGHT;\r\n            verdictToken = WHITE_TOKEN_ADDR;\r\n        } else if (token == BLACK_TOKEN_ADDR) {\r\n            domain = D_ENTITY_PAINT;\r\n            verdictToken = BLACK_TOKEN_ADDR;\r\n        } else {\r\n            revert Ontologic_UnknownEntityDomain();\r\n        }\r\n\r\n        // For MVP, we skip explicit evidence validation since the entity bundle\r\n        // references the proofs, and the HCS manifest contains the full evidence trail.\r\n        // In production, you would pass evidence[] as parameter and validate each proofHash\r\n        // exists in proofSeen mapping and matches the expected CMY outputs.\r\n\r\n        // Mint verdict token (1 unit)\r\n        (int64 responseCode,,) = HTS.mintToken(verdictToken, 1, new bytes[](0));\r\n        require(responseCode == 22, \"mint fail\");\r\n\r\n        // Emit Floridi proof event\r\n        emit ProofEntity(manifestHash, token, uri, msg.sender);\r\n\r\n        return true;\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                          INTERNAL HELPERS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    /**\r\n     * @notice Compute inputsHash for additive reasoning with order-invariance\r\n     * @dev Deterministic preimage: (min(A,B), max(A,B), domain, OP_ADD)\r\n     * @dev Order-invariant: inputsHashAdd(A,B,d) == inputsHashAdd(B,A,d)\r\n     * @param A First input token\r\n     * @param B Second input token\r\n     * @param domainHash Domain identifier\r\n     * @return inputsHash keccak256 of inputs tuple\r\n     */\r\n    function _inputsHashAdd(address A, address B, bytes32 domainHash)\r\n        internal\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        (address X, address Y) = A < B ? (A, B) : (B, A);\r\n        return keccak256(abi.encode(X, Y, domainHash, OP_ADD));\r\n    }\r\n\r\n    /**\r\n     * @notice Public wrapper for _inputsHashAdd for off-chain verification\r\n     * @param A First input token\r\n     * @param B Second input token\r\n     * @param domainHash Domain identifier\r\n     * @return inputsHash keccak256 of inputs tuple\r\n     */\r\n    function inputsHashAdd(address A, address B, bytes32 domainHash)\r\n        public\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        return _inputsHashAdd(A, B, domainHash);\r\n    }\r\n\r\n    /**\r\n     * @notice Compute inputsHash for subtractive reasoning\r\n     * @dev Deterministic preimage: (A, B, C, domain, OP_SUB)\r\n     * @param A First input token\r\n     * @param B Second input token\r\n     * @param C Third input token\r\n     * @param domainHash Domain identifier\r\n     * @return inputsHash keccak256 of inputs tuple\r\n     */\r\n    function inputsHashSub(address A, address B, address C, bytes32 domainHash)\r\n        public\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        return keccak256(abi.encode(A, B, C, domainHash, OP_SUB));\r\n    }\r\n\r\n    /**\r\n     * @notice Debug helper to validate parameters before execution\r\n     * @dev Returns contract-computed values and match status for off-chain validation\r\n     * @param A First input token\r\n     * @param B Second input token\r\n     * @param domainHash Domain hash from client\r\n     * @param inputsHash Inputs hash from client\r\n     * @return expectedDomain Contract's D_LIGHT constant\r\n     * @return expectedInputs Contract-computed inputsHash\r\n     * @return domainMatch True if domainHash matches D_LIGHT\r\n     * @return inputMatch True if inputsHash matches contract computation\r\n     */\r\n    function debugValidation(\r\n        address A,\r\n        address B,\r\n        bytes32 domainHash,\r\n        bytes32 inputsHash\r\n    )\r\n        external\r\n        view\r\n        returns (\r\n            bytes32 expectedDomain,\r\n            bytes32 expectedInputs,\r\n            bool domainMatch,\r\n            bool inputMatch\r\n        )\r\n    {\r\n        expectedDomain = D_LIGHT;\r\n        expectedInputs = _inputsHashAdd(A, B, domainHash);\r\n        domainMatch = (domainHash == D_LIGHT);\r\n        inputMatch = (inputsHash == expectedInputs);\r\n    }\r\n\r\n    /**\r\n     * @notice Check if a proof has been seen (executed)\r\n     * @param proofHash keccak256 hash of canonical proof JSON\r\n     * @return seen True if proof has been executed\r\n     */\r\n    function seen(bytes32 proofHash) external view returns (bool) {\r\n        return proofSeen[proofHash];\r\n    }\r\n\r\n    /**\r\n     * @notice Get the inputsHash for a previously executed proof\r\n     * @param proofHash keccak256 hash of canonical proof JSON\r\n     * @return inputsHash Cached inputsHash from original execution\r\n     */\r\n    function getInputsHash(bytes32 proofHash) external view returns (bytes32) {\r\n        return inputsHashOf[proofHash];\r\n    }\r\n\r\n    /**\r\n     * @notice Get RGB projection for a token in a domain\r\n     * @param domainHash Domain identifier\r\n     * @param token Token address\r\n     * @return rgb24 RGB value in 24-bit format (0xRRGGBB)\r\n     */\r\n    function getRGB(bytes32 domainHash, address token) external view returns (uint24) {\r\n        return projections[domainHash][token];\r\n    }\r\n\r\n    /**\r\n     * @notice Safely query token decimals with fallback\r\n     * @dev Returns 8 decimals if query fails (common fallback for fungible tokens)\r\n     * @param token Address of token to query\r\n     * @return decimals Number of decimal places\r\n     */\r\n    function _safeDecimals(address token) internal view returns (uint8 decimals) {\r\n        (bool success, bytes memory data) =\r\n            token.staticcall(abi.encodeWithSelector(IERC20.decimals.selector));\r\n        return success && data.length >= 32 ? abi.decode(data, (uint8)) : 8;\r\n    }\r\n\r\n    /**\r\n     * @notice Perform subtractive RGB operation based on domain\r\n     * @dev LIGHT domain: channelwise max(0, A - B)\r\n     * @dev PAINT domain: RGB→CMY, subtract, clamp, CMY→RGB\r\n     * @param a RGB value of first token (24-bit: 0xRRGGBB)\r\n     * @param b RGB value of second token (24-bit: 0xRRGGBB)\r\n     * @param domain Domain hash\r\n     * @return RGB result of subtraction\r\n     */\r\n    function _subtractRGB(uint24 a, uint24 b, bytes32 domain) internal pure returns (uint24) {\r\n        // LIGHT domain (color.light): channelwise subtraction with clamping\r\n        if (domain == keccak256(\"color.light\")) {\r\n            return _subtractLightRGB(a, b);\r\n        }\r\n\r\n        // PAINT domain (color.paint): RGB→CMY, subtract, clamp, CMY→RGB\r\n        if (domain == keccak256(\"color.paint\")) {\r\n            return _subtractPaintRGB(a, b);\r\n        }\r\n\r\n        // Default: return 0 for unknown domain\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * @notice Subtract in LIGHT domain (channelwise RGB)\r\n     */\r\n    function _subtractLightRGB(uint24 a, uint24 b) internal pure returns (uint24) {\r\n        uint8 ar = uint8(a >> 16);\r\n        uint8 ag = uint8(a >> 8);\r\n        uint8 ab = uint8(a);\r\n        uint8 br = uint8(b >> 16);\r\n        uint8 bg = uint8(b >> 8);\r\n        uint8 bb = uint8(b);\r\n        uint8 rr = ar > br ? ar - br : 0;\r\n        uint8 rg = ag > bg ? ag - bg : 0;\r\n        uint8 rb = ab > bb ? ab - bb : 0;\r\n        return uint24(rr) << 16 | uint24(rg) << 8 | uint24(rb);\r\n    }\r\n\r\n    /**\r\n     * @notice Subtract in PAINT domain (CMY model)\r\n     */\r\n    function _subtractPaintRGB(uint24 a, uint24 b) internal pure returns (uint24) {\r\n        uint8 ar = uint8(a >> 16);\r\n        uint8 ag = uint8(a >> 8);\r\n        uint8 ab = uint8(a);\r\n        uint8 br = uint8(b >> 16);\r\n        uint8 bg = uint8(b >> 8);\r\n        uint8 bb = uint8(b);\r\n        // RGB → CMY\r\n        uint8 ac = 255 - ar;\r\n        uint8 am = 255 - ag;\r\n        uint8 ay = 255 - ab;\r\n        uint8 bc = 255 - br;\r\n        uint8 bm = 255 - bg;\r\n        uint8 by = 255 - bb;\r\n        // Subtract in CMY\r\n        uint8 rc = ac > bc ? ac - bc : 0;\r\n        uint8 rm = am > bm ? am - bm : 0;\r\n        uint8 ry = ay > by ? ay - by : 0;\r\n        // CMY → RGB\r\n        return uint24(255 - rc) << 16 | uint24(255 - rm) << 8 | uint24(255 - ry);\r\n    }\r\n}\r\n"
      }
    }
  }
}